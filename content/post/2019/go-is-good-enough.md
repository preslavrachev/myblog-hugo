+++
author = "Preslav Rachev"
categories = ["Programming"]
date = "2019-10-18T22:00:00+00:00"
description = ""
featured_image = ""
slug = ""
tags = ["Programming", "Golang", "Go"]
title = "Go is Good Enough"

+++

Have you heard about the [Pareto Principle](https://en.wikipedia.org/wiki/Pareto_principle)? Also known as the 80/20 Rule, it states that for many aspects of life, 80% of the effects come from 20% of the inputs. Flip it around and the opposite is also true: reaching out for the rest of the 20% requires 80% of the initial effort. It is amazing how many manifestations of both exist in real life. One of the big wisdoms in life - it is often not the smartest, fastest, or strongest individuals that leave a dent. It is the ones pragmatic enough to achieve the 80% with 20% of the effort and energy spent. 

The slight deviation aside, the same very much applies to the Go programming language. It is just good enough. Go won't win the category of language design, neither is it the fastest one on the market. Nor is it the safest member of the bunch. The truth is, what Go offers on the table might seem pretty boring at first. It is a compiled, statically typed language with an extremely reduced syntax, a somewhat simplified concurrency model, and a bit of memory safety. Nothing near close to the speed of C, the beauty of Ruby or the dogmatic memory management of Rust. 

And this is what makes Go succeed. It does not have any of those things, but it is simple and fast enough to get you going on a new project without having to second-guess your approach every second. The lack of features helps reduce the cognitive burden on both the programmer and the compiler. The speed, file-size and memory consumption of the final applications is more optimal than those of 80% of applications built using other technologies.

Will Go ever be the best in any single programming language category? Probably no. Is it good enough to sustain 80% of your programming efforts? Absolutely!
