<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Preslav Rachev">
<meta name="description" content="Even in a simple language like Go, concurrently updating mutable state is like playing with fire. Take this piece of code, for example:
l := content.NewLoader() l.PageCount = 5 c := l.Load(bytes) Can you be sure that what you are loading is actually going to contain five pages? What if another goroutine having access to l, interjects and sets PageCount to 1000? Or worse, updates the state of l such that a panic is inevitable?" />
<meta name="keywords" content="programming, golang, python, Programming, Go, Golang, Tips" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://example.com/2019/10/06/simple-immutable-builders-in-go-using-value-receivers/" />


    <title>
        
            Simple Immutable Builders in Go, Using Value Receivers :: Random Bits of Wisdom  â€” Hello Friend NG Theme
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://example.com/main.min.2f0d18b84270567c723bff340b09ab08db3a7634237cd9667d052eb6b14669b8.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://example.com/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://example.com/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://example.com/favicon-16x16.png">
    <link rel="manifest" href="https://example.com/site.webmanifest">
    <link rel="mask-icon" href="https://example.com/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://example.com/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">


<meta itemprop="name" content="Simple Immutable Builders in Go, Using Value Receivers">
<meta itemprop="description" content="Even in a simple language like Go, concurrently updating mutable state is like playing with fire. Take this piece of code, for example:
l := content.NewLoader() l.PageCount = 5 c := l.Load(bytes) Can you be sure that what you are loading is actually going to contain five pages? What if another goroutine having access to l, interjects and sets PageCount to 1000? Or worse, updates the state of l such that a panic is inevitable?">


<meta itemprop="datePublished" content="2019-10-06T07:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-10-06T07:00:00&#43;00:00" />
<meta itemprop="wordCount" content="488">



<meta itemprop="keywords" content="Programming,Go,Golang,Tips," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com"/>

<meta name="twitter:title" content="Simple Immutable Builders in Go, Using Value Receivers"/>
<meta name="twitter:description" content="Even in a simple language like Go, concurrently updating mutable state is like playing with fire. Take this piece of code, for example:
l := content.NewLoader() l.PageCount = 5 c := l.Load(bytes) Can you be sure that what you are loading is actually going to contain five pages? What if another goroutine having access to l, interjects and sets PageCount to 1000? Or worse, updates the state of l such that a panic is inevitable?"/>



    <meta property="article:section" content="Programming" />



    <meta property="article:published_time" content="2019-10-06 07:00:00 &#43;0000 UTC" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://example.com/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/preslav.me</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://example.com/about/">About</a></li><li><a href="https://example.com/post/">Blog</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://example.com/2019/10/06/simple-immutable-builders-in-go-using-value-receivers/">Simple Immutable Builders in Go, Using Value Receivers</a></h2>

            

            <div class="post-content">
                

<p>Even in a simple language like Go, concurrently updating mutable state is like playing with fire. Take this piece of code, for example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">content</span>.<span style="color:#a6e22e">NewLoader</span>()
<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">PageCount</span> = <span style="color:#ae81ff">5</span>
<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">bytes</span>)</code></pre></div>
<p>Can you be sure that what you are loading is actually going to contain five pages? What if another goroutine having access to <code>l</code>, interjects and sets <code>PageCount</code> to 1000? Or worse, updates the state of <code>l</code> such that a panic is inevitable?</p>

<p>The simplest solution to this is to pack as much of the initial state configuration into the initialisation step. Constructors do not exist in Go, but unless we speak about a data-only struct (no logic), I would always recommend providing an initialiZer func <code>NewLoader(...)</code> and keeping as much of the state   of the struct unexported. This will transform the previous piece of code into:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">content</span>.<span style="color:#a6e22e">NewLoader</span>(<span style="color:#a6e22e">pageCount</span>: <span style="color:#ae81ff">5</span>)
<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">bytes</span>)</code></pre></div>
<p>The problem there becomes apparent when you start having more than three arguments:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">content</span>.<span style="color:#a6e22e">NewLoader</span>(<span style="color:#a6e22e">pageCount</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">offset</span>: <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">protocol</span>: <span style="color:#e6db74">&#34;HTTP&#34;</span>, <span style="color:#75715e">//... )
</span><span style="color:#75715e"></span><span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">bytes</span>)</code></pre></div>
<p>How can we initialize <code>Loader</code> in a safe way, providing for some defaults, and without having to pack tens of parameters into the initializing func? There are various ways to achieve this. I have already written about <a href="https://preslav.me/2019/07/07/implementing-a-functional-style-builder-in-go/" target="_blank">one way</a> to approach this, another could be the functional options approach, suggested by <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank">Dave Cheney</a>.</p>

<h1 id="value-receivers-as-builder-methods">Value receivers as builder methods</h1>

<p>The simplest one I have found so far, takes advantage of an innate property of the Go language. Namely, the fact that everything is passed by value. One of the first questions many go beginners ask about, is the difference between <a href="https://tour.golang.org/methods/8" target="_blank">value and pointer receivers</a>. Pointer receivers are usually the preferred way to go, often, as an (premature) optimization, rather than because modifications are required. A bit underrated, value receivers have one big advantage, which is that they are safe for concurrent use. What a value receiver would get is a copy of the original value. This makes them perfect for implementing builder methods:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Loader</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">pageSize</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewLoader</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Loader</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Loader</span>{
		<span style="color:#a6e22e">pageSize</span>:<span style="color:#ae81ff">10</span>, <span style="color:#75715e">// default
</span><span style="color:#75715e"></span>	}
}

<span style="color:#75715e">// check the use of a value receiver here
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">Loader</span>) <span style="color:#a6e22e">WithPageSize</span>(<span style="color:#a6e22e">ps</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Loader</span> {
	<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">pageSize</span> = <span style="color:#a6e22e">ps</span>
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">l</span>
}

<span style="color:#75715e">// The rest could be your usual pointer receivers
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Loader</span>) <span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">bytes</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">string</span> {
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}</code></pre></div>
<p>The fact that we use a value receiver will cause the value of <code>l</code> to be copied, so technically, what we set <code>pageSize</code> to is a completely different place in memory. This is why we have to return a pointer to it and and reassign <code>l</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">content</span>.<span style="color:#a6e22e">NewLoader</span>().
			<span style="color:#a6e22e">withPageSize</span>(<span style="color:#ae81ff">5</span>)

<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">bytes</span>)</code></pre></div>
<p>This will cause some copying and a bit of work for the garbage collector, but in the grand scheme of things, it will be a negligible overhead. The safety that you gain is far more important.</p>

<p>Let me know what you think.</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
  				<p>
  					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://example.com/tags/programming">Programming</a></span><span class="tag"><a href="https://example.com/tags/go">Go</a></span><span class="tag"><a href="https://example.com/tags/golang">Golang</a></span><span class="tag"><a href="https://example.com/tags/tips">Tips</a></span>
  				</p>
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
                <span><a href="https://example.com">Preslav Rachev</a></span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            <span> <a href="https://example.com/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="https://example.com/bundle.min.8047d1b063234db7e4f910f9d54abd62686428b775f14770e6c6314980002e1d3014e6f9d5df0df37d0a5fd3a15f20b320fb949c4f014e74059de1c57eb0e40a.js" integrity="sha512-gEfRsGMjTbfk&#43;RD51Uq9YmhkKLd18Udw5sYxSYAALh0wFOb51d8N830KX9OhXyCzIPuUnE8BTnQFneHFfrDkCg=="></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-131031623-1', 'auto');
        ga('send', 'pageview');
    </script>



    </body>
</html>
