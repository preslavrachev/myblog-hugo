<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Preslav Rachev ">
<meta name="description" content="My foray into Elixir brought forward many more similarities between it and Go, than I originally expected. One of them is how both handle concurrency. With respect to that, creating Elixir-style stateful actors in Go is surprisingly easy. Answering the question, whether one needs them, or can make use of them, I’d leave to the user. If you approach me back saying that the same thing can be achieved using a channel or a map with sync." />
<meta name="keywords" content="programming, golang, python, elixir, Programming, Golang, Elixir, Erlang" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://preslav.me/2020/03/07/elixir-style-actors-in-golang/" />


    <title>
        
            Elixir-Style Actors in Go :: Random Bits of Wisdom 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://preslav.me/main.min.2f0d18b84270567c723bff340b09ab08db3a7634237cd9667d052eb6b14669b8.css">


    
        <link rel="stylesheet" type="text/css" href="https://preslav.me/css/cookieconsent.min.css">
    



    <link rel="apple-touch-icon" sizes="180x180" href="https://preslav.me/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://preslav.me/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://preslav.me/favicon-16x16.png">
    <link rel="manifest" href="https://preslav.me/site.webmanifest">
    <link rel="mask-icon" href="https://preslav.me/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://preslav.me/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">


<meta itemprop="name" content="Elixir-Style Actors in Go">
<meta itemprop="description" content="My foray into Elixir brought forward many more similarities between it and Go, than I originally expected. One of them is how both handle concurrency. With respect to that, creating Elixir-style stateful actors in Go is surprisingly easy. Answering the question, whether one needs them, or can make use of them, I’d leave to the user. If you approach me back saying that the same thing can be achieved using a channel or a map with sync.">


<meta itemprop="datePublished" content="2020-03-07T17:04:29&#43;01:00" />
<meta itemprop="dateModified" content="2020-03-07T17:04:29&#43;01:00" />
<meta itemprop="wordCount" content="1518">



<meta itemprop="keywords" content="Programming,Golang,Elixir,Erlang," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://preslav.me/images/avatar.jpg"/>

<meta name="twitter:title" content="Elixir-Style Actors in Go"/>
<meta name="twitter:description" content="My foray into Elixir brought forward many more similarities between it and Go, than I originally expected. One of them is how both handle concurrency. With respect to that, creating Elixir-style stateful actors in Go is surprisingly easy. Answering the question, whether one needs them, or can make use of them, I’d leave to the user. If you approach me back saying that the same thing can be achieved using a channel or a map with sync."/>



    <meta property="article:section" content="Programming" />



    <meta property="article:published_time" content="2020-03-07 17:04:29 &#43;0100 &#43;0100" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://preslav.me/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/preslav.me</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://preslav.me/about/">About</a></li><li><a href="https://preslav.me/post/">Blog</a></li><li><a href="https://preslav.me/projects/">Projects</a></li><li><a href="https://preslav.me/contact/">Contact</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
<main class="post">

    <div class="post-info">
        <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-clock">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>8 minutes

            

            | <a href="#disqus_thread"
                style="padding: 2px; border-radius: 1px; text-decoration: none; background-color: #fe5186; color: #ffffff">start
                a discussion</a>
        </p>
    </div>

    <article>
        <h1 class="post-title">
            <a href="https://preslav.me/2020/03/07/elixir-style-actors-in-golang/">Elixir-Style Actors in Go</a>
        </h1>

        

        <div class="post-content">
            

<p>My foray into <a href="https://elixir-lang.org/" target="_blank">Elixir</a> brought forward many more similarities between it and Go, than I originally expected. One of them is how both handle concurrency. With respect to that, creating Elixir-style stateful actors in Go is surprisingly easy. Answering the question, whether one needs them, or can make use of them, I’d leave to the user. If you approach me back saying that the same thing can be achieved using a channel or a map with <code>sync.Mutex</code> slapped on it, you’d be (almost) right. Yet, it’s worth exploring different ways of thinking.</p>

<h1 id="a-10-000-foot-view-of-elixir">A 10.000-foot view of Elixir</h1>

<p>For those not aware of it, Elixir is a functional language. Everything runs inside an immutable function scope, and no state remains on the table. A function can only work on what it has been fed with. Functions reside inside modules and are being executed inside Erlang processes.</p>

<p>Technical differences aside, you can think of processes as the equivalent of Go’s goroutines. A function chain call runs inside a process/goroutine. When the outermost function returns, the process/goroutine ends. A process/goroutine can spawn other processes/goroutines to achieve concurrent execution of tasks. Go synchronizes over channels while Elixir over a message inbox that is built into every process. Using the built-in receive keyword, a function’s execution blocks inside a process, until a certain type of message gets received</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">receive do
    <span style="color:#75715e"># Don&#39;t get too caught up on the Elixir syntax.</span>
    <span style="color:#75715e"># For now, it is only important to know that :message_a is equivalent</span>
    <span style="color:#75715e"># to a string with the value of &#34;message_a&#34;</span>
    <span style="color:#75715e"># Those are called &#34;atoms&#34; and are quite often used in Ruby-like laguages</span>
    {<span style="color:#e6db74">:message_a</span>, msg} <span style="color:#f92672">-&gt;</span>
        do_something_with(msg)
end</code></pre></div>
<p>Fundamentally, this is the same as having a <a href="https://play.golang.org/p/rZkdET2ZhJl" target="_blank">goroutine block its execution waiting on a channel</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">message</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">val</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#a6e22e">msgStream</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">message</span>)

<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">out</span> <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">message</span>) {
    <span style="color:#a6e22e">out</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">message</span>{<span style="color:#a6e22e">val</span>: <span style="color:#e6db74">&#34;hello world&#34;</span>}
}(<span style="color:#a6e22e">msgStream</span>)

<span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">msgStream</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%+v&#34;</span>, <span style="color:#a6e22e">msg</span>)</code></pre></div>
<p>Whether you are waiting on a message to arrive in your inbox, or explicitly set a blocking channel as a communication mechanism, to me, it describes the same paradigm.</p>

<h1 id="turn-goroutines-into-stateful-actors">Turn goroutines into stateful actors</h1>

<p>Clear until now? Alright. Let’s move on. I already mentioned that Elixir is a functional language. Everything that gets passed to a function is immutable, and the only way to change it, is to return a new version of it. This means that looping constructs are not possible, since it would imply modifying and keeping track of a counter variable. The way functional languages achieve the effect of looping is through recursion (or to be more precise tail recursion):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">def loop(<span style="color:#ae81ff">5</span>) do
    <span style="color:#75715e"># Elixir uses pattern-matching when choosing which function to call.</span>
    <span style="color:#75715e"># In our case, as soon as its gets a count == 5, it will stop the loop</span>
    <span style="color:#ae81ff">5</span>
end

def loop(count) do
    <span style="color:#75715e"># Just print the count, but use pipes (|&gt;)</span>
    <span style="color:#75715e"># instead of wrapping in a function call -&gt; IO.puts(count)</span>
    <span style="color:#75715e"># Pipes totally save the day, when you have multiple call chains</span>
    count
    <span style="color:#f92672">|&gt;</span> <span style="color:#a6e22e">IO</span><span style="color:#f92672">.</span>puts()

    loop(count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
end</code></pre></div>
<h2 id="from-recursion-to-actors">From recursion to actors</h2>

<p>What if we take this recursion example and think of it as a never-ending loop. The first call to the function sets the initial state, and the function keeps calling itself ad-infinitum.</p>

<p>Now, this is where the purely functional paradigm breaks. We already learned that Erlang allows for other processes to communicate to us. This means that if our never ending recursive function receives a message from the outside, it can use its payload to call itself with a modified version of its initial state. Keeping in mind that receiving a message is a blocking operation, the process will simply linger around, not using any CPU resources, until our the right message arrives.</p>

<p>We can use the same messaging paradigm to poke inside the state of our never-ending function. Since it runs inside a separate process, the only way to do that is to send an appropriate message to it, pass our current process’ ID (PID) and let it send us a message back.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#a6e22e">Calculator</span> do
    def start do
    <span style="color:#75715e"># creates a separate process with its own internal state</span>
    spawn(fn <span style="color:#f92672">-&gt;</span> loop(<span style="color:#ae81ff">0</span>) end)
    end

    defp loop(current_value) do
    new_value <span style="color:#f92672">=</span>
        receive do
        <span style="color:#75715e"># with this type of message, we can fetch the state of our calculator</span>
        {<span style="color:#e6db74">:get</span>, caller_pid} <span style="color:#f92672">-&gt;</span>
            send(caller_pid, {<span style="color:#e6db74">:response</span>, current_value})
            current_value

        <span style="color:#75715e"># with this type of message, we can modify the state of our calculator</span>
        {<span style="color:#e6db74">:add</span>, value} <span style="color:#f92672">-&gt;</span>
            current_value <span style="color:#f92672">+</span> value
        end

    loop(new_value)
    end
end</code></pre></div>
<p>Let&rsquo;s test our calculator process:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#a6e22e">CalculatorTest</span> do
    def test_calculator do
    calc_pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">Calculator</span><span style="color:#f92672">.</span>start()

        <span style="color:#75715e"># Like `receive`, `send` is built-in and take a PID, as well as a message</span>
        <span style="color:#75715e"># self() returns the process id (PID) of the current process</span>
        <span style="color:#75715e"># Like in Go, every piece of Elixir/Erlang code runs in a process</span>
    send(calc_pid, {<span style="color:#e6db74">:get</span>, self()})

        <span style="color:#75715e"># `receive` will block, until we receive a message,</span>
        <span style="color:#75715e"># that matches the expected pattern - {:response, value}</span>
    receive do
        {<span style="color:#e6db74">:response</span>, value} <span style="color:#f92672">-&gt;</span>
        value <span style="color:#f92672">|&gt;</span> <span style="color:#a6e22e">IO</span><span style="color:#f92672">.</span>puts()
    end

    send(calc_pid, {<span style="color:#e6db74">:add</span>, <span style="color:#ae81ff">100</span>})

    send(calc_pid, {<span style="color:#e6db74">:get</span>, self()})

    receive do
        {<span style="color:#e6db74">:response</span>, value} <span style="color:#f92672">-&gt;</span>
        value <span style="color:#f92672">|&gt;</span> <span style="color:#a6e22e">IO</span><span style="color:#f92672">.</span>puts()
    end
    end
end</code></pre></div>
<p>In essence, our never-ending function becomes what Elixir calls a stateful server process, an implementation of the <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank">Actor model</a>. Actors are great for isolating critical state and allowing for concurrent communication to it, ensuring that only one change happens at a time.</p>

<h2 id="from-elixir-to-go">From Elixir to Go</h2>

<p>Ok now that we know how things work in Elixir land, achieving the same thing on Go is super straightforward.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">in</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">message</span>)
    <span style="color:#a6e22e">out</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">newCalculator</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">in</span>, <span style="color:#a6e22e">out</span>)

    <span style="color:#a6e22e">in</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">message</span>{<span style="color:#a6e22e">operation</span>: <span style="color:#e6db74">&#34;get&#34;</span>}
    <span style="color:#a6e22e">state</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">out</span>
    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Current state: %d&#34;</span>, <span style="color:#a6e22e">state</span>)

    <span style="color:#a6e22e">in</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">message</span>{<span style="color:#a6e22e">operation</span>: <span style="color:#e6db74">&#34;add&#34;</span>, <span style="color:#a6e22e">value</span>: <span style="color:#ae81ff">100</span>}
    <span style="color:#a6e22e">in</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">message</span>{<span style="color:#a6e22e">operation</span>: <span style="color:#e6db74">&#34;get&#34;</span>}
    <span style="color:#a6e22e">state</span> = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">out</span>
    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Current state: %d&#34;</span>, <span style="color:#a6e22e">state</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">message</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">operation</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">value</span>     <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newCalculator</span>(<span style="color:#a6e22e">initialState</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">in</span> <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">out</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">state</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">initialState</span>
    <span style="color:#66d9ef">for</span> {
        <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">in</span>
        <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">operation</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;add&#34;</span>:
            <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Adding %d to the current state&#34;</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">value</span>)
            <span style="color:#a6e22e">state</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">value</span>

        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;get&#34;</span>:
            <span style="color:#a6e22e">out</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">state</span>
        }
    }
}</code></pre></div>
<p>One thing to note is that since we can use an infinite-loop, we should just use that, especially, since based on my knowledge Go is not particularly optimized for long-cycle recursion. But the main premise remains the same. A function gets called with some initial state and returns a channel. The function starts an endless loop, blocking on the channel. If we push a value to that channel, the function will take it, update the state and block again.</p>

<h1 id="what-are-actors-good-for">What are actors good for?</h1>

<h2 id="private-state">Private state</h2>

<p>So, now that we unveiled the mystery behind actors, it’s a good point to discuss what they might be useful for.</p>

<p>One thing that immediately comes to mind, is achieving globally accessible, but truly private, synchronized state. This is currently achieved with the use of channels, <code>sync.Mutex</code>, or the new <code>sync.Map</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SynchronizedMap</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
    <span style="color:#a6e22e">internal</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SynchronizedMap</span>) <span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">interface</span>{}) {
    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">Lock</span>()
    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">internal</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">Unlock</span>()
}</code></pre></div>
<p>The fragility of this approach comes from the fact that there is no real private state in Go applications. The map we named <code>internal</code> in the above example is only protected from outside access. Any piece of code inside the same package as our <code>SynchronizedMap</code> can freely access and modify its internals, leading to unexpected consequences. While this shouldn&rsquo;t be a concern in most cases, it&rsquo;s definitely good to keep in mind for special cases.</p>

<h2 id="stateful-autonomous-agents">Stateful autonomous agents</h2>

<p>Where the Actor model shines is the orchestration of systems of Actor instances - autonomous agents. Each Actor instance is able to change its state, reacting to the messages sent to it. Actor instances can easily spawn other Actor instances, which only the creating actors (supervisors) have control over (private state, remember). Supervisors can also take over failures of the actors their are responsible for, potentially, killing some off, and restarting them with a clean state. Taking this example to extremes, groroutines being fairly cheap, one can easily imagine a swarm of thousands of Actor instances, in a deeply nested hierarchy, with multiple levels of supervising actors taking over their &ldquo;progeny&rdquo;. This is the unique selling proposition of Erlang, but as I hope to have demonstrated, could be replicated in Go too.</p>

<p>As discussed in the beginning, I would leave the discussions about this approach&rsquo;s practicality, as well as its other applications to the reader. I would love to hear your thoughts. Do not hesitate to drop me a comment, or start a new discussion.</p>

<hr />

<h1 id="resources">Resources</h1>






<style scoped>
  @media (max-width: 640px) {
    .embed-image {
      min-width: 100%;
    }
  }
</style>
<div
  style="display:flex; flex-wrap: wrap; border: 1px solid #d4d4d4; width:100%; margin-bottom: 1rem">

  
  <div class="embed-image"
    style="flex:1; background: url(https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1519435676i/38732242._UY630_SR1200,630_.jpg); background-size:cover; background-position:center; min-height: 120px">
  </div>
  

  <div class="embed-content" style="flex:3; padding: 1rem;"><a
      href="https://www.goodreads.com/book/show/38732242-elixir-in-action">
      <div class="title"
        style="font-weight: 800; margin-bottom: 1rem; font-size:120%">
        Elixir in Action</div>
    </a>
    <div class="embed-description" style="margin-bottom:1rem; font-size:80%">
      The Elixir language blends the battle-tested power and stability of the Erlang virtual machine with an approachable and expressive syntax...</div>
    <div class="embed-meta" style="font-size:60%">
      <div style="float:left; max-width:80%"><a
          href="https://www.goodreads.com/book/show/38732242-elixir-in-action">https://www.goodreads.com | </a></div>
      <div style="float: right">Created with <a
          href="https://noembed.preslav.me/">NoEmbed</a></div>
    </div>
  </div>
</div>

<p>One of the best books about learning Elixir, and certainly, the one that inspired me to write this post. Saša Jurić&rsquo;s explanations are clear and demonstrative, especially on complex topics such as this one. If you like this blog, and would love to support my passion for reading great books, you can <a href="https://amzn.to/39AXJ6T" target="_blank">buy it on Amazon using this special link</a>. Thanks!</p>

        </div>
    </article>

    <hr />

    <div class="post-info">
        <p>
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-tag meta-icon">
                <path
                    d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z">
                </path>
                <line x1="7" y1="7" x2="7" y2="7"></line>
            </svg><span class="tag"><a
                    href="https://preslav.me/tags/programming">Programming</a></span><span class="tag"><a
                    href="https://preslav.me/tags/golang">Golang</a></span><span class="tag"><a
                    href="https://preslav.me/tags/elixir">Elixir</a></span><span class="tag"><a
                    href="https://preslav.me/tags/erlang">Erlang</a></span>
        </p>

        <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-file-text">
                <path
                    d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z">
                </path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>1518 Words</p>

        <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                class="feather feather-calendar">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>2020-03-07 16:04 &#43;0000
        </p>
    </div>

    
    <div class="pagination">
        <div class="pagination__title">
            <span
                class="pagination__title-h"></span>
            <hr />
        </div>

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://preslav.me/2020/03/14/a-step-outside-the-comfort-zone/">
                    <span class="button__icon">←</span>
                    <span class="button__text">A Step Outside the Comfort Zone</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://preslav.me/2020/03/01/use-the-git-history/">
                    <span class="button__text">Use the Git History to Identify Pain Points in Any Project</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>
    

    
    <div id="comments" class="thin">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "preslav" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
    
</main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
                <span><a href="https://preslav.me">Preslav Rachev</a></span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            <span> <a href="https://preslav.me/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="https://preslav.me/bundle.min.8047d1b063234db7e4f910f9d54abd62686428b775f14770e6c6314980002e1d3014e6f9d5df0df37d0a5fd3a15f20b320fb949c4f014e74059de1c57eb0e40a.js" integrity="sha512-gEfRsGMjTbfk&#43;RD51Uq9YmhkKLd18Udw5sYxSYAALh0wFOb51d8N830KX9OhXyCzIPuUnE8BTnQFneHFfrDkCg=="></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-131031623-1', 'auto');
        ga('send', 'pageview');
    </script>


	
		<script src="https://preslav.me/js/cookieconsent.min.js"></script>
	

	
		<script src="https://preslav.me/js/site.js"></script>
	


    </body>
</html>
