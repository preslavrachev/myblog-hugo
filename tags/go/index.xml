<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Go on Random Bits of Wisdom</title>
        <link>https://preslav.me/tags/go/</link>
        <description>Recent content in Go on Random Bits of Wisdom</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sat, 20 Jun 2020 07:08:59 +0000</lastBuildDate>
        <atom:link href="https://preslav.me/tags/go/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Musings on Go and Generics ...</title>
            <link>https://preslav.me/scratchpad/2020/musings-go-generics/</link>
            <pubDate>Sat, 20 Jun 2020 07:08:59 +0000</pubDate>
            
            <guid>https://preslav.me/scratchpad/2020/musings-go-generics/</guid>
            <description>This isn&amp;rsquo;t yet another interpretation on the latest Go generics proposal, because I haven&amp;rsquo;t fully read it through.</description>
            <content type="html"><![CDATA[<p>I feel like I am the only person in the Go programming community these days, who hasn&rsquo;t expressed an opinion about the <a href="https://blog.golang.org/generics-next-step">latest generics proposal</a>. I wish, I could say that the reason was just a lack of time. Yet, what I really wanted was for the hype to die down a little, so that I could spend some unbiased time with the generics-enabled <a href="https://go2goplay.golang.org/">playground</a> and see for myself, whether I like the proposal or not.</p>

<p>When I was still doing Java full-time, generics were the sort of thing that I would get for granted, and I would not question their use. They were just there, and everyone was using them, so I just went with the flow. From experience, they have worked well while trying to convince the compiler that what you are trying to do is right. Yet trying to decipher the author&rsquo;s intention by just reading generic code has always been awful.</p>

<p>Upon entering Go, programming without them felt like some sort of barbaric masochism at first. Al this type checking at all times &hellip; ugh. Then, I realized that if the kind of problems I was trying to solve could usually be approached in a simpler manner than I thought. Not every piece of code needs to be battle-tested and ready to be used in every situation imaginable. Sometimes, all you need is code that solves your particular problem, and one that is easy to decipher later on.</p>

<p>Which brings me to the particular proposal. From the little I saw, it seems to be simple to comprehend for language newcomers, because it essentially essentially expands upon the concept of interfaces. Yet, the few examples of code I saw were also difficult enough to read (all those brackets) that I am quite doubtful that I would use it, and I certainly don&rsquo;t want to be the one having to read it and debug it. I fear that every new language feature becomes a sort of a golden hammer, which gets thrown at every problem, and I certainly don&rsquo;t want that to happen with generics. Utility libraries can certainly benefit from those, but I&rsquo;d try not to us them a lot in application code.</p>

<p>Anyway, this became quite a lengthy post for someone who&rsquo;s had a very vague look. I can&rsquo;t imagine what would come out, once I have actually read the entire proposal through.</p>

<p>A few articles on the topic that are on my to-read list:</p>

<ul>
<li><a href="https://rakyll.org/generics-proposal/">Early notes on the generics proposal · Go, the unwritten parts</a></li>
<li><a href="https://pmihaylov.com/go-generics-draft-design/">A Concise Guide to the Latest Go Generics Draft Design | Preslav Mihaylov</a></li>
<li><a href="https://mdlayher.com/blog/go-generics-draft-design-building-a-hashtable/">Go generics draft design: building a hashtable · Matt Layher</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Go: Copy a Reader Into a Writer</title>
            <link>https://preslav.me/scratchpad/2020/golang-copy-reader-writer/</link>
            <pubDate>Tue, 16 Jun 2020 07:08:59 +0000</pubDate>
            
            <guid>https://preslav.me/scratchpad/2020/golang-copy-reader-writer/</guid>
            <description>Something so simple, and yet, so easy to forget right when you need it. How does one read from a Reader and write to a Writer at the same time?</description>
            <content type="html"><![CDATA[<p>Something so simple, and yet, so easy to forget right when you need it. How does one read from a <code>Reader</code> and write to a <code>Writer</code> at the same time?</p>

<p><code>io.Copy</code> to the rescue. I can best demonstrate it with a small HTTP server, where the contents of a JSON is being written directly into the HTTP response:</p>

<pre><code class="language-go">package main

import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
	&quot;os&quot;
)

func main() {
	log.Panic(http.ListenAndServe(&quot;:8080&quot;, http.HandlerFunc(handle)))
}

func handle(w http.ResponseWriter, r *http.Request) {
	fp, err := os.Open(&quot;store.json&quot;)
	defer fp.Close()
	if err != nil {
		log.Printf(&quot;ERR: %s&quot;, err)
	}

	io.Copy(w, fp)
}
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>A Simple Way to Keep a Go App Up and Running</title>
            <link>https://preslav.me/2020/05/24/the-simplest-way-to-keep-a-go-app-up-and-running/</link>
            <pubDate>Sun, 24 May 2020 10:28:44 +0100</pubDate>
            
            <guid>https://preslav.me/2020/05/24/the-simplest-way-to-keep-a-go-app-up-and-running/</guid>
            <description>Poor man’s Kubernetes</description>
            <content type="html"><![CDATA[<p>I am a lazy programmer, experimenting with new ideas all the time. For these, running and deploying tiny Go apps as single executables is the closest way to see something in action. Yet, quickly written Go apps often panic, and crash altogether. While I am a strong defender of making sure that all possible errors are checked, real software is bound to eventually crash, no matter what. In such situations, the fastest solution is usually a simple restart.</p>

<p><a href="https://www.freedesktop.org/wiki/Software/systemd/">Systemd</a>, <a href="https://www.docker.com/">Docker</a>, <a href="https://kubernetes.io/">Kubernetes</a> - all took process supervision to a new level. If you are working on production-level software, chances are you already have some infrastructure layer in place that will take care of this. On the other hand, setting up tons of infrastructure is the last thing you want to think about, when working on your quickly made side project. This is where the following 5-line Bash script comes in place:</p>

<pre><code class="language-bash">#!/bin/sh

while true; do
    .myapp
done

# call this file run.sh and use nohup to start it
# nohup ./run.sh &amp;
</code></pre>

<p>That’s it. Instead of running your app directly, you can use <code>nohup</code> to run it through the Bash script: <code>nohup run.sh &amp;</code>.</p>

<hr />

<p>NOTE: While fairly easy to set up, this is by no means a safe way to take care of process restarts. It is also not an excuse to avoid thorough error checking. It will help you see your app quickly, but as soon as it starts getting serious traffic, you need to consider setting up the proper infrastructure. I can <a href="https://preslav.me/contact/">help</a> with that.</p>
]]></content>
        </item>
        
        <item>
            <title>A Crystal in Go’s World</title>
            <link>https://preslav.me/2020/01/26/a-crystal-in-go-s-world/</link>
            <pubDate>Sun, 26 Jan 2020 08:35:04 +0000</pubDate>
            
            <guid>https://preslav.me/2020/01/26/a-crystal-in-go-s-world/</guid>
            <description>Imagine a programming language with the ergonomic syntax of Ruby, the speed of execution of C, the concurrency model of Go, and last but not least, a compiler that performs null checks at compile time. Sounds like a dream? Well, this language exists, but chances are, you haven’t heard of it so far.
Meet Crystal!
Crystal is all of the above, plus it has types, outstanding documentation, and a strong community, delivering a steady stream of new libraries (a.</description>
            <content type="html"><![CDATA[

<p>Imagine a programming language with the ergonomic syntax of Ruby, the speed of execution of C, the concurrency model of Go, and last but not least, a compiler that performs null checks at compile time. Sounds like a dream? Well, this language exists, but chances are, you haven’t heard of it so far.</p>

<p>Meet <a href="https://crystal-lang.org/">Crystal</a>!</p>


    <img src="/images/2020/image-crystal.png"  alt="Crystal home page"  class="center"  style="border-radius: 8px;"  />



<p>Crystal is all of the above, plus it has types, <a href="https://crystal-lang.org/reference/overview/">outstanding documentation</a>, and a strong community, delivering a steady stream of new libraries (a.k.a “shards”). Don’t get fooled by the current version number (0.32.1). Crystal has been around for quite a few years (since 2012) and has a mature set of language features and an ecosystem of good libraries.</p>

<h2 id="where-does-the-speed-come-from">Where does the speed come from?</h2>

<p>Crystal produces fast and lightweight native applications using the LLVM infrastructure. When I say fast, I mean, <a href="https://github.com/kostya/benchmarks">really fast</a>. Take the fastest Go code you can find and chances are, the same code in Crystal will perform at least on par with it, and often quite a bit faster. Measuring Crystal’s performance against that of Ruby makes no sense.</p>

<p>There are no runtime frameworks or virtual machines necessary. One can just grab the compiled binary and deploy it. When compared with deploying and running a Ruby application, this feels like a whole different league.</p>

<p>Note that there are some caveats, which I am going to discuss in a future blog post. For now, let’s just say that building and distribution are equally as easy, as those in Rust. As of yet, nothing can beat the Go compiler speed-wise, but my experience with the Crystal tooling has been more than pleasant so far.</p>

<h2 id="csp-style-concurrency">CSP-style concurrency</h2>

<p>One of the things that make Go so interesting is its concurrency model. The idea about goroutines that communicate via channels is based on an approach dating back to the late 1970s, called <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes (CSP)</a>. Crystal uses an analogous approach. Programs run in what is known as <a href="https://crystal-lang.org/reference/guides/concurrency.html">“fibers”</a>. The main fiber can spawn any number of concurrent fibers that send and receive data via blocking channels.</p>

<pre><code class="language-crystal">channel = Channel(Nil).new 
spawn do    
	puts &quot;Before send&quot;    
	channel.send(nil)    
	puts &quot;After send&quot; 
end  

puts &quot;Before receive&quot; 
channel.receive 
puts &quot;After receive&quot;
</code></pre>

<h2 id="why-re-invent-ruby-in-2020">Why re-invent Ruby in 2020?</h2>

<p>The creators of Crystal obviously didn’t intend on changing the world of programming by creating a new language. They just <a href="https://web.archive.org/web/20181126095302/https://manas.tech/blog/2016/04/01/the-story-behind-crystal.html">loved Ruby</a> and felt it sad to leave it for a more performant and type-safe alternative. Due to a series of trade-offs at the implementation level, Ruby is still slower and more memory-hungry than its competitors. Despite perfectly serving the needs of a large segment of Web users through Rails, its performance puts it at the back of the pack, when it comes to other use cases.</p>

<p>The point is fair and valid. As a language, Ruby has a concise and elegant syntax for writing. Once beyond the basic idioms, writing Ruby evokes pure joy. Crystal brings that joy to an even higher level through type-safety, native speed, and extremely simple concurrency model.</p>

<p>Don’t get me wrong, I like Go too, precisely because of its verbosity and lack of idioms. When working with others on a big project, I’d prefer more ceremony and hoops, in the name of transparency and equal code comprehension. Different languages exist to serve different purposes and be used by different groups of people. The trick is knowing when to use and when the other.</p>

<h2 id="so-is-crystal-worth-having-a-look">So, is Crystal worth having a look?</h2>

<p>Absolutely! If only to know that it exists and keep an eye on it, I’d go check it out and write a few applications with it. Whether Crystal will take off in the future is a bit more difficult to say, however. As mentioned, the 99% resemblance to Ruby is nice, and so is the blazing-fast performance. Yet, I am missing the Crystal community’s drive towards more prominence. There has been a long-awaited move towards a 1.0 release, which is a crucial milestone and would surely bring in many newcomers. To my understanding, the language and its tooling are stable enough for a 1.0 release.</p>

<p>I understand that Crystal does not have the backing of either Google or Mozilla. Neither does it have multi-billion-dollar use-cases to put on its home page. I understand that fighting for the same space with Go, C/C++, and Rust is an unfair battle. Yet, I also believe that we’re long past the days when choosing one technology over another was a zero-sum game. All it needs is a little push.</p>

<p>I am hoping for the best!</p>
]]></content>
        </item>
        
        <item>
            <title>Reflecting on My Experience With Go, One Year After</title>
            <link>https://preslav.me/2020/01/17/reflecting-on-my-experience-with-go-one-year-after/</link>
            <pubDate>Fri, 17 Jan 2020 08:35:04 +0000</pubDate>
            
            <guid>https://preslav.me/2020/01/17/reflecting-on-my-experience-with-go-one-year-after/</guid>
            <description>In my little more than a year day-to-day developer experience with Go, I have so far learned three things:
 I can change my entire view of how programming works, even after 12+ years of doing it in one form or another. People are blaming Java for all the wrong reasons People are praising Go for all the wrong reasons  Let me explain. This post is not about saying that “language A is better than language B”, or vice versa.</description>
            <content type="html"><![CDATA[

<p>In my little more than a year day-to-day developer experience with Go, I have so far <strong>learned three things</strong>:</p>

<ol>
<li>I can change my entire view of how programming works, even after 12+ years of doing it in one form or another.</li>
<li>People are blaming Java for all the wrong reasons</li>
<li>People are praising Go for all the wrong reasons</li>
</ol>

<p>Let me explain. This post is not about saying that “language A is better than language B”, or vice versa. It is about asking ourselves the question why things work the way they do, and whether doing them differently is a bad, or potentially, good thing.</p>

<p>Before joining the Go camp, I had worked quite a few years as a Java developer, with all the stereotypes that this role could evoke in one’s head. I co-developed data-processing systems for various industries. Yet, much of the code I wrote was just boilerplate: passing data from one format to the other, or devising complex abstractions behind what should have really just been calling a function and obtaining its result. Yes, the code was difficult to comprehend, but I was proud of it for this exact reason. The more hoops I created, the more secure I felt that:</p>

<ol>
<li>I was doing what I thought was right</li>
<li>If people didn’t understand the code, they’d have to come to me for an advice, further boosting my ego.</li>
</ol>

<h2 id="the-language-is-not-to-blame-for-this">The language is not to blame for this</h2>

<p>The fact that much of the existing Java code is full of bureaucracy has nothing to do with the language itself, or with its platform. Our developer community should bear the sole responsibility. I can assure anyone that perfectly functioning Java applications can be written without 90% of the ceremony. They will be smaller and run faster. Most probably, easier to comprehend, too. And yet, they won’t get you hired in any well-respected company. They just won’t pass the <em>developer prejudice</em> test. I know. I’ve seen many elegant solutions and rejected them for not being /idiomatic/ enough.</p>

<h2 id="go-isn-t-a-silver-bullet-either">Go isn’t a silver bullet either</h2>

<p>For much of the same reasoning, jumping ship towards Go, just because “it is not Java”, won’t bring anyone far. Even before I started writing Go, I had heard and read many stories, about how simple and fast it made everything, how little ceremony it had, compared to Java, how it would eventually kill all other languages, etc. All blah, blah. Despite all of the above being true, you have to discover the truth in each for yourselves. If you approach the language out of desperation with your current way of working, you’re going to be set for a rough path.</p>

<p>See, if you all you wanted was to get a faster running (name language of choice), you could certainly do it. Yet, holding on to the mental baggage of your previous experience will be hard and messy. My first Go project started out as a rewrite of a Spring Boot app I’d started earlier, so I thought I’d just organize it the same way. To keep the story short, let’s just say it was a spectacular disaster. Only after I started from scratch, did it really start taking off.</p>

<h2 id="go-is-a-language-without-with-less-idioms">Go is a language without (with less) idioms</h2>

<p>Let’s do a naive math experiment. Imagine that you could create valid programming expressions combining any 3 keywords, from a programming language’s vocabulary. Thus, if a language only has 10 keywords, the maximum number of possible expressions is 10 * 9 * 8 = 720. In contrast, a language, with, say, 20 keywords would end up having 20 * 19 * 18 = 6840 expressions. Twice as many keywords would result in almost 10 times as many expressions!</p>

<p>Languages tend to encourage the creation and use of idioms. With that many possible expressions, it’s a normal behaviour for an individual, or a group of people to start associating and using expressions for certain things. The problems usually occur when another group comes with its own way of expressing the same thing. Both are perfectly valid, but each group would have issues understanding the other.</p>

<p>This is not to say that Go having a very strict and concise nature, is totally devoid of idioms. That would be impossible. It is in our nature to try to associate and abstract certain concepts. Yet, when a language has a deliberately smaller vocabulary, the chances for different groups accidentally finding multiple ways of doing the same thing are smaller. This helps the communication between people a great deal, but comes with a very obvious downside. Code (or any written expression, for that matter) without idioms is very, very verbose.</p>

<p>So, whoever told you that Go is not a verbose language, probably either lied to you on purpose, or had’n really seen any other programming languages up until that point. But hey, we agreed that verbosity in the name of communication and common understanding is a actually a good thing, right?s</p>

<h2 id="go-is-a-test-for-senior-engineers">Go is a test for senior engineers</h2>

<p>A lot has been said about the initial concept about Go, and how the idea was to design a language for juniors fresh out of college, and with little programming experience. I think that understanding the beauty of going back to the roots of programming, can be a cathartic experience for many seasoned programmers.</p>

<p>See, junior programmers start with little baggage and preconceptions, so in their view, anything that can be done with code is fair and justified. Including, burning a CPU, or erasing a disk due to an arithmetic error.</p>

<p>Somewhere along the middle of the career path, a bunch of principles start to pile up. All of them out of the desire to step on what’s already been learned, and to make sure that things are smoothly and safely without immediate supervision. Learning and applying the principles is great, because it ensures a gradual path forward. But for many, it becomes a dogma which they blindly stick to, without asking whether a simpler alternative could be better.</p>

<p>The problem with principles is that they only work well around 80% of the time. It is the remaining 20% that can be disastrous for a project, or for one’s career. It is the understanding where to apply a principle, and where to deliberately throw it away in the name of pragmatism, which turns a software engineer into a senior software engineer.</p>

<p>To really appreciate Go, one needs to learn how to discern what makes it and its community stand out from the rest. One needs to go through a phase of utter disgust with the language, for it “lacking” certain feature. Moving on despite the urge to go back to a familiar ground, would result in one of two things:</p>

<ol>
<li>Make one realise that indeed, the Go language is not what they need or want</li>
<li>Learn to appreciate going back to the roots, as well as when to favour pragmatism over principles</li>
</ol>

<p>In any case, it would be an interesting experience.</p>
]]></content>
        </item>
        
        <item>
            <title>Using Gohack for Temporary Modifications to Go Module Dependencies</title>
            <link>https://preslav.me/2020/01/10/using-gohack-for-temporary-modifications-to-go-module-dependencies/</link>
            <pubDate>Fri, 10 Jan 2020 19:14:17 +0100</pubDate>
            
            <guid>https://preslav.me/2020/01/10/using-gohack-for-temporary-modifications-to-go-module-dependencies/</guid>
            <description>I started programming Go right at the time when the topic of modularization heated up. Of course, we all know how it all played out with Go modules. They are here and they are (IMO) great. I have spent a significant amount programming Python before virtual environments were really a thing, and believe me, things got really messed up at times.
One big disadvantage of modules is that one can’t really edit them.</description>
            <content type="html"><![CDATA[<p>I started programming Go right at the time when the topic of <em>modularization</em> heated up. Of course, we all know how it all played out with Go modules. They are here and they are (IMO) great. I have spent a significant amount programming Python before virtual environments were really a thing, and believe me, things got really messed up at times.</p>

<p>One big disadvantage of modules is that one can’t really edit them. For a good reason, of course. You want them to be clean and reproducible, but occasionally, one needs to just insert a <code>log.Printf</code> or a tiny inspection function somewhere. One option is to call <code>mod vendor</code>, but this would copy all the dependencies to the vendor folder. Clearly, a lot more overhead than what one would need.</p>

<p>This is where <a href="https://github.com/rogpeppe/gohack">gohack</a> comes in really handy. It uses a clever feature of the Go modules, called /replace/. It allows the user to manually override the path to a given dependency. Instead of doing all of this manually, however, gohack will do it all for you.</p>

<p>After installing go-installing gohack, go to your module-bound Go project and use it instead of <code>go get</code> for a given dependency:</p>

<pre><code>gohack get example.com/foo/bar
</code></pre>

<p>gohack will fetch the code and store it in a special place inside your <code>$HOME</code> directory. It will also do the go.mod replacements for you:</p>

<pre><code>replace example.com/foo/bar =&gt; /home/me/gohack/example.com/foo/bar
</code></pre>

<p>All the edits you now do to the dependency that was added to your <code>$HOME</code> folder, will now affect the project that uses it.</p>

<p>Once you have done checking, and want to revert to using the original dependency, you can simply use the undo functionality:</p>

<pre><code>gohack undo example.com/foo/bar
</code></pre>

<p>or to revert all changes to all “hacked” dependencies:</p>

<pre><code>gohack undo
</code></pre>

<hr />








<div class="embed"
  style="display:flex; flex-wrap: wrap; border: 1px solid #d4d4d4; width:100%; margin-bottom: 1rem">

  
  <div class="embed-image"
    style="flex:1; background: url(https://avatars0.githubusercontent.com/u/66491?s=400&amp;v=4); background-size:cover; background-position:center; min-height: 120px">
  </div>
  

  <div class="embed-content" style="flex:3; padding: 1rem;"><a
      href="https://github.com/rogpeppe/gohack">
      <div class="title"
        style="font-weight: 800; margin-bottom: 1rem; font-size:120%">
        rogpeppe/gohack</div>
    </a>
    <div class="embed-description" style="margin-bottom:1rem; font-size:80%">
      Make temporary edits to your Go module dependencies - rogpeppe/gohack</div>
    <div class="embed-meta" style="font-size:60%">
      <div style="float:left; max-width:80%"><a
          href="https://github.com/rogpeppe/gohack">https://github.com | </a></div>
      <div style="float: right">Created with <a
          href="https://linqable.pro/">Linqable</a></div>
    </div>
  </div>
</div>
]]></content>
        </item>
        
        <item>
            <title>Panic Without Worry</title>
            <link>https://preslav.me/2019/12/14/panic-without-worry/</link>
            <pubDate>Sat, 14 Dec 2019 22:00:00 +0000</pubDate>
            
            <guid>https://preslav.me/2019/12/14/panic-without-worry/</guid>
            <description>In the Go community, there is some kind of paranoia around panicking, as if it’s the worst thing that can happen to your application. In fact, it often is the better option. Think about Go programs as CLI applications. Would you rather crash right away and let the user react, or hang, trying to recover? The same applies to applications running as services. Modern tooling makes it easy to automatically restart a crashing service within seconds.</description>
            <content type="html"><![CDATA[<p>In the Go community, there is some kind of paranoia around panicking, as if it’s the worst thing that can happen to your application. In fact, it often is the better option. Think about Go programs as CLI applications. Would you rather crash right away and let the user react, or hang, trying to recover? The same applies to applications running as services. Modern tooling makes it easy to automatically restart a crashing service within seconds.</p>

<p>When necessary, panic without worry.</p>
]]></content>
        </item>
        
        <item>
            <title>Go is Good Enough</title>
            <link>https://preslav.me/2019/10/18/go-is-good-enough/</link>
            <pubDate>Fri, 18 Oct 2019 22:00:00 +0000</pubDate>
            
            <guid>https://preslav.me/2019/10/18/go-is-good-enough/</guid>
            <description>Have you heard about the Pareto Principle? Also known as the 80&amp;frasl;20 Rule, it states that for many aspects of life, 80% of the effects come from 20% of the inputs. Flip it around and the opposite is also true: reaching out for the rest of the 20% requires 80% of the initial effort. It is amazing how many manifestations of both exist in real life. One of the big wisdoms in life - it is often not the smartest, fastest, or strongest individuals that leave a dent.</description>
            <content type="html"><![CDATA[<p>Have you heard about the <a href="https://en.wikipedia.org/wiki/Pareto_principle">Pareto Principle</a>? Also known as the <em><sup>80</sup>&frasl;<sub>20</sub> Rule</em>, it states that for many aspects of life, 80% of the effects come from 20% of the inputs. Flip it around and the opposite is also true: reaching out for the rest of the 20% requires 80% of the initial effort. It is amazing how many manifestations of both exist in real life. One of the big wisdoms in life - it is often not the smartest, fastest, or strongest individuals that leave a dent. It is the ones pragmatic enough to achieve the 80% with 20% of the effort and energy spent.</p>

<p>The slight deviation aside, the same very much applies to the Go programming language. It is just good enough. Go won&rsquo;t win the category of language design, neither is it the fastest one on the market. Nor is it the safest member of the bunch. The truth is, what Go offers on the table might seem pretty boring at first. It is a compiled, statically typed language with an extremely reduced syntax, a somewhat simplified concurrency model, and a bit of memory safety. Nothing near close to the speed of C, the beauty of Ruby or the dogmatic memory management of Rust.</p>

<p>And this is what makes Go succeed. It does not have any of those things, but it is simple and fast enough to get you going on a new project without having to second-guess your approach every second. The lack of features helps reduce the cognitive burden on both the programmer and the compiler. The speed, file-size and memory consumption of the final applications is more optimal than those of 80% of applications built using other technologies.</p>

<p>Will Go ever be the best in any single programming language category? Probably no. Is it good enough to sustain 80% of your programming efforts? Absolutely!</p>

<hr />








<div class="embed"
  style="display:flex; flex-wrap: wrap; border: 1px solid #d4d4d4; width:100%; margin-bottom: 1rem">

  
  <div class="embed-image"
    style="flex:1; background: url(https://upload.wikimedia.org/wikipedia/commons/d/d3/Pareto_principle_applied_to_community_fundraising.jpg); background-size:cover; background-position:center; min-height: 120px">
  </div>
  

  <div class="embed-content" style="flex:3; padding: 1rem;"><a
      href="https://en.wikipedia.org/wiki/Pareto_principle">
      <div class="title"
        style="font-weight: 800; margin-bottom: 1rem; font-size:120%">
        Pareto principle - Wikipedia</div>
    </a>
    <div class="embed-description" style="margin-bottom:1rem; font-size:80%">
      </div>
    <div class="embed-meta" style="font-size:60%">
      <div style="float:left; max-width:80%"><a
          href="https://en.wikipedia.org/wiki/Pareto_principle">https://en.wikipedia.org | </a></div>
      <div style="float: right">Created with <a
          href="https://linqable.pro/">Linqable</a></div>
    </div>
  </div>
</div>
]]></content>
        </item>
        
        <item>
            <title>Simple Immutable Builders in Go, Using Value Receivers</title>
            <link>https://preslav.me/2019/10/06/simple-immutable-builders-in-go-using-value-receivers/</link>
            <pubDate>Sun, 06 Oct 2019 07:00:00 +0000</pubDate>
            
            <guid>https://preslav.me/2019/10/06/simple-immutable-builders-in-go-using-value-receivers/</guid>
            <description>Even in a simple language like Go, concurrently updating mutable state is like playing with fire. Take this piece of code, for example:
l := content.NewLoader() l.PageCount = 5 c := l.Load(bytes)  Can you be sure that what you are loading is actually going to contain five pages? What if another goroutine having access to l, interjects and sets PageCount to 1000? Or worse, updates the state of l such that a panic is inevitable?</description>
            <content type="html"><![CDATA[

<p>Even in a simple language like Go, concurrently updating mutable state is like playing with fire. Take this piece of code, for example:</p>

<pre><code class="language-go">l := content.NewLoader()
l.PageCount = 5
c := l.Load(bytes)
</code></pre>

<p>Can you be sure that what you are loading is actually going to contain five pages? What if another goroutine having access to <code>l</code>, interjects and sets <code>PageCount</code> to 1000? Or worse, updates the state of <code>l</code> such that a panic is inevitable?</p>

<p>The simplest solution to this is to pack as much of the initial state configuration into the initialisation step. Constructors do not exist in Go, but unless we speak about a data-only struct (no logic), I would always recommend providing an initialiZer func <code>NewLoader(...)</code> and keeping as much of the state   of the struct unexported. This will transform the previous piece of code into:</p>

<pre><code class="language-go">l := content.NewLoader(pageCount: 5)
c := l.Load(bytes)
</code></pre>

<p>The problem there becomes apparent when you start having more than three arguments:</p>

<pre><code class="language-go">l := content.NewLoader(pageCount: 5, offset: 3, protocol: &quot;HTTP&quot;, //... )
c := l.Load(bytes)
</code></pre>

<p>How can we initialize <code>Loader</code> in a safe way, providing for some defaults, and without having to pack tens of parameters into the initializing func? There are various ways to achieve this. I have already written about <a href="https://preslav.me/2019/07/07/implementing-a-functional-style-builder-in-go/">one way</a> to approach this, another could be the functional options approach, suggested by <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Dave Cheney</a>.</p>

<h1 id="value-receivers-as-builder-methods">Value receivers as builder methods</h1>

<p>The simplest one I have found so far, takes advantage of an innate property of the Go language. Namely, the fact that everything is passed by value. One of the first questions many go beginners ask about, is the difference between <a href="https://tour.golang.org/methods/8">value and pointer receivers</a>. Pointer receivers are usually the preferred way to go, often, as an (premature) optimization, rather than because modifications are required. A bit underrated, value receivers have one big advantage, which is that they are safe for concurrent use. What a value receiver would get is a copy of the original value. This makes them perfect for implementing builder methods:</p>

<pre><code class="language-go">type Loader struct {
	pageSize int
}

func NewLoader() *Loader {
	return &amp;Loader{
		pageSize:10, // default
	}
}

// check the use of a value receiver here
func (l Loader) WithPageSize(ps int) *Loader {
	l.pageSize = ps
	return &amp;l
}

// The rest could be your usual pointer receivers
func (l *Loader) Load(bytes []byte) string {
	// ...
}
</code></pre>

<p>The fact that we use a value receiver will cause the value of <code>l</code> to be copied, so technically, what we set <code>pageSize</code> to is a completely different place in memory. This is why we have to return a pointer to it and and reassign <code>l</code>:</p>

<pre><code class="language-go">l := content.NewLoader().
			withPageSize(5)

c := l.Load(bytes)
</code></pre>

<p>This will cause some copying and a bit of work for the garbage collector, but in the grand scheme of things, it will be a negligible overhead. The safety that you gain is far more important.</p>

<p>Let me know what you think.</p>
]]></content>
        </item>
        
        <item>
            <title></title>
            <link>https://preslav.me/scratchpad/260920191021/</link>
            <pubDate>Thu, 26 Sep 2019 11:20:00 +0000</pubDate>
            
            <guid>https://preslav.me/scratchpad/260920191021/</guid>
            <description>Chiefly, Go sacrifices expressiveness for uniformity.
The general principle is to favour the transparent and ready-to-hand over the remote and opaque, the concrete and literal over the abstract and magical. It’s like speaking a language without metaphors.
Learning Go won’t teach you any exciting new computer science concepts, or introduce you to a whole new paradigm of software development (for that, try Idris). But it will give you a better understanding of the breadth and variety of the design space for programming languages, at a time when mainstream languages generally seem to be converging (Kotlin is rather like Swift, is rather like Typescript, etc).</description>
            <content type="html"><![CDATA[<blockquote>
<p>Chiefly, Go sacrifices expressiveness for uniformity.</p>

<p>The general principle is to favour the transparent and ready-to-hand over the remote and opaque, the concrete and literal over the abstract and magical. It’s like speaking a language without metaphors.</p>

<p>Learning Go won’t teach you any exciting new computer science concepts, or introduce you to a whole new paradigm of software development (for that, try <a href="http://www.idris-lang.org/">Idris</a>). But it will give you a better understanding of the breadth and variety of the design space for programming languages, at a time when mainstream languages generally seem to be converging (Kotlin is rather like Swift, is rather like Typescript, etc). Sometimes it isn’t the innovative new features that distinguish a language, but its choice of restrictions.</p>
</blockquote>








<div class="embed"
  style="display:flex; flex-wrap: wrap; border: 1px solid #d4d4d4; width:100%; margin-bottom: 1rem">

  
  <div class="embed-image"
    style="flex:1; background: url(https://opencredo.com/wp-content/uploads/2016/10/Visualization_of_two_dimensions_of_a_NK_fitness_landscape-400x292.png); background-size:cover; background-position:center; min-height: 120px">
  </div>
  

  <div class="embed-content" style="flex:3; padding: 1rem;"><a
      href="https://opencredo.com/blogs/java-go-back/">
      <div class="title"
        style="font-weight: 800; margin-bottom: 1rem; font-size:120%">
        From Java to Go, and Back Again - OpenCredo</div>
    </a>
    <div class="embed-description" style="margin-bottom:1rem; font-size:80%">
      Introduction: fitness landscapes, Cassandra, and making things worse   In evolutionary biology, a fitness landscape is a way of visualising the relationship between genotypes and reproductive success. Each possible variation of a genotype is projected onto a position on a map, and the height of the terrain at that position represents the reproductive success associated […]</div>
    <div class="embed-meta" style="font-size:60%">
      <div style="float:left; max-width:80%"><a
          href="https://opencredo.com/blogs/java-go-back/">https://opencredo.com | </a></div>
      <div style="float: right">Created with <a
          href="https://linqable.pro/">Linqable</a></div>
    </div>
  </div>
</div>
]]></content>
        </item>
        
        <item>
            <title>Mixtape Retrospective: Time to Split the Monolith?</title>
            <link>https://preslav.me/2019/08/03/mixtape-retrospective-time-to-split-the-monolith/</link>
            <pubDate>Sat, 03 Aug 2019 22:00:00 +0000</pubDate>
            
            <guid>https://preslav.me/2019/08/03/mixtape-retrospective-time-to-split-the-monolith/</guid>
            <description>I have recently made my project Mixtape open to the world. Mixtape is a search and discovery platform for podcasts, built exclusively using Go. I decided to use Go primarily because of its compiler&amp;rsquo;s ability to deliver small, self-contained executables with close-to-metal native performance and extremely low memory footprint. It was also a way to battle-test the stack and figure out where and how it will benefit future projects in my portfolio.</description>
            <content type="html"><![CDATA[

<p>I have recently made my project <a href="https://mixtape.preslav.me/">Mixtape</a> open to the world. <a href="https://mixtape.preslav.me/">Mixtape</a> is a search and discovery platform for podcasts, built exclusively using Go. I decided to use Go primarily because of its compiler&rsquo;s ability to deliver small, self-contained executables with close-to-metal native performance and extremely low memory footprint. It was also a way to battle-test the stack and figure out where and how it will benefit future projects in my portfolio.</p>

<p>In the few months running to the initial release, I learned a lot and was confronted by a couple of challenges that other fellow programmers have also been raving about:</p>

<ul>
<li><p>Panics are lurking at every corner. A single panic can kill your entire app. The single (thought not 100% reliable) cure is to handle every error explicitly. This leads to code which is often interrupted by the same three lines:</p>

<pre><code class="language-go">result, err := doSomething()
if err != nil {
// do something with the error, and potentially return or throw a Panic
}
</code></pre></li>

<li><p>Codebases do not scale well. Whether due to the simplistic syntax of the language, data types, or its approach to packaging and encapsulation, there is a certain point, in which either the cost of setting up proper abstractions or that of copying the same piece of code multiple times, ultimately slows down development efforts.</p></li>
</ul>

<h1 id="build-deploy-take-a-step-back">Build, deploy, take a step back</h1>

<p>I had to build a whole app in Go, only to realize that what I initially considered shortcomings, were features in disguise, intentionally put by the design team as protection against bloat. They are a very good indicator of when the time has come to split an application into two or more smaller apps. Some call them micro-services. I tend to think of them as commands, in the UNIX sense of single-purpose apps that do one thing and one thing alone.</p>

<p>When you start thinking this way, you realize that resilience and fault tolerance move away from the responsibilities of the single app/service/command and shift to the orchestration layer. That is not to say that you should not check for errors in your Go apps. On the contrary, check and cover what you can. However, not every error can be, or even, <strong>should be</strong> covered by your app. Some are even out of your control. Especially, when using 3rd-party code. Admit it, services fail and will fail, and that&rsquo;s their natural behavior.</p>

<p>By having the components split from one another at the service level, you allow each one to fail separately, without these causing problems on the rest or bringing the entire system down. With infrastructure tech such as Docker and Kubernetes, restarting a faulty service, or load-balancing between a myriad of service copies has become rather easy.</p>

<h1 id="no-s-t-sherlock">No s**t, Sherlock!</h1>

<p>All of that should have seemed obvious, you say? After, all, Go has been pointed time and again as the programming language of the Cloud (which, TBH, is pure marketing BS, from the same people that called MongoDB &ldquo;web-scale&rdquo; back in the day). Why did I go for a monolith, then? Because, developing a monolith is the most natural way you can start a project, especially when working on it alone. I come from the world of Java, where, assuming you have enough CPU and RAM to sustain it, your app can practically run forever out of a single instance. You can have as many separate threads as your hardware allows for, and each of those may fail, without this necessarily bringing your entire app down. You might end up in deadlocks and resource starvation might cause the app to crash, but this won&rsquo;t happen as often as people imagine.</p>

<p>So, it was our of practicality that I started building <a href="https://mixtape.preslav.me/">Mixtape</a> as a monolith. Now, I am at a crossroads. I have tried to stay away from messing up with infrastructure configuration for as long as I could. However, if I decide to continue with Go, I might have to eventually start splitting the app. Only time will tell.</p>
]]></content>
        </item>
        
    </channel>
</rss>
