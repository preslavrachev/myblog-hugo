<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Random Bits of Wisdom</title>
    <link>https://example.com/tags/go/</link>
    <description>Recent content in Go on Random Bits of Wisdom</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 14 Dec 2019 22:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://example.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Panic Without Worry</title>
      <link>https://example.com/2019/12/14/panic-without-worry/</link>
      <pubDate>Sat, 14 Dec 2019 22:00:00 +0000</pubDate>
      
      <guid>https://example.com/2019/12/14/panic-without-worry/</guid>
      <description>In the Go community, there is some kind of paranoia around panicking, as if it’s the worst thing that can happen to your application. In fact, it often is the better option. Think about Go programs as CLI applications. Would you rather crash right away and let the user react, or hang, trying to recover? The same applies to applications running as services. Modern tooling makes it easy to automatically restart a crashing service within seconds.</description>
    </item>
    
    <item>
      <title>Go is Good Enough</title>
      <link>https://example.com/2019/10/18/go-is-good-enough/</link>
      <pubDate>Fri, 18 Oct 2019 22:00:00 +0000</pubDate>
      
      <guid>https://example.com/2019/10/18/go-is-good-enough/</guid>
      <description>Have you heard about the Pareto Principle? Also known as the 80&amp;frasl;20 Rule, it states that for many aspects of life, 80% of the effects come from 20% of the inputs. Flip it around and the opposite is also true: reaching out for the rest of the 20% requires 80% of the initial effort. It is amazing how many manifestations of both exist in real life. One of the big wisdoms in life - it is often not the smartest, fastest, or strongest individuals that leave a dent.</description>
    </item>
    
    <item>
      <title>Simple Immutable Builders in Go, Using Value Receivers</title>
      <link>https://example.com/2019/10/06/simple-immutable-builders-in-go-using-value-receivers/</link>
      <pubDate>Sun, 06 Oct 2019 07:00:00 +0000</pubDate>
      
      <guid>https://example.com/2019/10/06/simple-immutable-builders-in-go-using-value-receivers/</guid>
      <description>Even in a simple language like Go, concurrently updating mutable state is like playing with fire. Take this piece of code, for example:
l := content.NewLoader() l.PageCount = 5 c := l.Load(bytes) Can you be sure that what you are loading is actually going to contain five pages? What if another goroutine having access to l, interjects and sets PageCount to 1000? Or worse, updates the state of l such that a panic is inevitable?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/microblog/260920191021/</link>
      <pubDate>Thu, 26 Sep 2019 11:20:00 +0000</pubDate>
      
      <guid>https://example.com/microblog/260920191021/</guid>
      <description>Chiefly, Go sacrifices expressiveness for uniformity.
The general principle is to favour the transparent and ready-to-hand over the remote and opaque, the concrete and literal over the abstract and magical. It’s like speaking a language without metaphors.
Learning Go won’t teach you any exciting new computer science concepts, or introduce you to a whole new paradigm of software development (for that, try Idris). But it will give you a better understanding of the breadth and variety of the design space for programming languages, at a time when mainstream languages generally seem to be converging (Kotlin is rather like Swift, is rather like Typescript, etc).</description>
    </item>
    
    <item>
      <title>Mixtape Retrospective: Time to Split the Monolith?</title>
      <link>https://example.com/2019/08/03/mixtape-retrospective-time-to-split-the-monolith/</link>
      <pubDate>Sat, 03 Aug 2019 22:00:00 +0000</pubDate>
      
      <guid>https://example.com/2019/08/03/mixtape-retrospective-time-to-split-the-monolith/</guid>
      <description>I have recently made my project Mixtape open to the world. Mixtape is a search and discovery platform for podcasts, built exclusively using Go. I decided to use Go primarily because of its compiler&amp;rsquo;s ability to deliver small, self-contained executables with close-to-metal native performance and extremely low memory footprint. It was also a way to battle-test the stack and figure out where and how it will benefit future projects in my portfolio.</description>
    </item>
    
  </channel>
</rss>