<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Heroku on Random Bits of Wisdom</title>
        <link>https://preslav.me/tags/heroku/</link>
        <description>Recent content in Heroku on Random Bits of Wisdom</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sat, 20 Apr 2019 07:30:04 +0000</lastBuildDate>
        <atom:link href="https://preslav.me/tags/heroku/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Deploying a Native Go Binary on Heroku</title>
            <link>https://preslav.me/2019/04/20/deploying-native-go-binary-on-heroku/</link>
            <pubDate>Sat, 20 Apr 2019 07:30:04 +0000</pubDate>
            
            <guid>https://preslav.me/2019/04/20/deploying-native-go-binary-on-heroku/</guid>
            <description>My company, KI labs recently held its first hackathon in our Munich office. My team and I went for a very cool mobile app idea that promotes healthy walking competitions among colleagues and friends. Though the app itself deserves a proper introduction, I will talk about it in a separate post. This time I will focus on one problem I experienced while working on the app&amp;rsquo;s backend part, written in Go.</description>
            <content type="html"><![CDATA[

<p>My company, <a href="https://www.ki-labs.com/">KI labs</a> recently held its first hackathon in our Munich office. My team and I  went for a very cool mobile app idea that promotes healthy walking competitions among colleagues and friends. Though the app itself deserves a proper introduction, I will talk about it in a separate post. This time I will focus on one problem I experienced while working on the app&rsquo;s backend part, written in Go.</p>

<p>The challenges with using the Go language aside, one unanticipated hurdle was actually getting the backend to run in Heroku. I know, I could have gone for a different solution, but my usual workflow is to deploy to Heroku, until the requirements push for an alternative approach. And Heroku already supports deploying Go applications. Or at least, that&rsquo;s what the <a href="https://www.heroku.com/go">documentation</a> says. And indeed, after the stress of the hackathon, I figured it out, but at the time, getting Heroku to build a Go application that uses modules seemed like it needed more time than we actually had.</p>

<p>Due to the limited time constraints, I decided to take a shortcut and use what has traditionally been one of the Go&rsquo;s strongest selling points - creating a static binary and running it natively inside a VM or a container. But Heroku can&rsquo;t run native apps directly, can it? Or at least, it won&rsquo;t allow you to run those directly.</p>

<h2 id="the-solution">The Solution</h2>

<p>The trick is to make the installer think that it is going to use a certain <a href="https://devcenter.heroku.com/articles/buildpacks">Buildpack</a>, but actually in your Procfile you override the control and execute a native binary directly.</p>

<p>Heroku uses certain triggers to initiate the start of an instance. For example, the presence of a <code>package.json</code> file (Node.js) or <code>pom.xml</code> / <code>build.gradle</code> (Java), <code>requirements.txt</code> / <code>setup.py</code> (Python), etc.</p>

<pre><code class="language-bash">GOOS=linux go build server.go
</code></pre>

<p>For our needs, we might as well hijack the <a href="https://github.com/heroku/heroku-buildpack-nodejs">Node.js Buildpack</a>. This is relatively simple. In order to trick Heroku, all we need is a <code>package.json</code> file, which lists a few basic properties needed for the Buildpack initialization:</p>

<pre><code class="language-json">{ &quot;name&quot;: &quot;appname&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;dependencies&quot;: {} }
</code></pre>

<p>With the <code>package.json</code> file in place, we need a simple <code>Procfile</code>, which will tell Heroku what to execute once the Buildpack initialization has finiehsed. In our case, this will be the already compiled Go executable:</p>

<pre><code class="language-yaml">web: ./main $PORT
</code></pre>

<p>A minor disadvantage of this approach is that we need to check the compiled binary into our git repository. I would do this on a separate branch, which I would try not to merge back to master and delete as soon as no longer necessary. By default, Heroku would use the <code>master</code> branch when buiding an application, so we need to be assertive when pushing our special deployment branch:</p>

<pre><code class="language-bash">git push heroku my-deployment-branch:master
# tell Heroku to use my deployment branch as its `master`
</code></pre>

<p>That&rsquo;s it! If fyour application is built using a technology that Heroku might not be actively supporting, or you are in for an extra performance boost (e.g. using Swift, Rust, C, etc) this tip might help you.</p>

<h1 id="related-resources">Related Resources</h1>

<ul>
<li><a href="http://blog.jan-ahrens.eu/2014/06/17/heroku-with-c.html">Heroku with C</a></li>
<li><a href="https://github.com/heroku/heroku-buildpack-go">heroku/heroku-buildpack-go: Heroku Go Buildpack</a></li>
<li><a href="https://github.com/heroku/go-getting-started">heroku/go-getting-started: Getting Started with Go on Heroku https://devcenter.heroku.com/articles/getting-started-with-go</a></li>
<li><a href="https://devcenter.heroku.com/articles/go-support">Heroku Go Support | Heroku Dev Center</a></li>
<li><a href="https://www.heroku.com/go">Deploy, manage, scale Go apps in the cloud | Heroku</a></li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
